<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ float数据在内存中的表示形式</title>
      <link href="/p/2019-07-28-c++-float-in-memory.html"/>
      <url>/p/2019-07-28-c++-float-in-memory.html</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>参考：<a href="https://blog.csdn.net/hemingliang1987/article/details/11630409" target="_blank" rel="noopener">https://blog.csdn.net/hemingliang1987/article/details/11630409</a><br>简单地说，一个float型实数在内存中占4个字节，即32个二进制bit，从低位到高位依次叫第0位到第31位。<br>这32位可以分为3个部分：符号位（第31位），阶码（第30位到第23位共8位），尾数（最低23位）。 </p><ol><li>符号位。最高位也就是第31位表示这个实数是正数还是负数，为0表示正数或0，为1表示负数。</li><li>阶码。第30位到第23位这8个二进制位表示该实数转化为规格化的二进制实数后的指数与127(127即所谓偏移量)之和即所谓阶码。<br>规格化的二进制实数的指数只能在-127~+127之间，所以，一个float型数的最大值在+2^127即+3.4*10^38，最小值在-2^127即-3.4*10^38。 </li><li>尾数。其他最低的23位即第22位到第0位表示该实数转化为规格化的二进制实数后小数点以后的其余各位即所谓尾数。</li></ol><a id="more"></a><hr><h1 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h1><p>例如，将十进制178.125表示成机器内的32个字节的二进制形式。</p><h2 id="第一步：将178-125表示成二进制数"><a href="#第一步：将178-125表示成二进制数" class="headerlink" title="第一步：将178.125表示成二进制数"></a>第一步：将178.125表示成二进制数</h2><p>(178.125)(十进制数)=(10110010.001)(二进制形式)</p><h2 id="第二步：将二进制形式的浮点实数转化为规格化的形式"><a href="#第二步：将二进制形式的浮点实数转化为规格化的形式" class="headerlink" title="第二步：将二进制形式的浮点实数转化为规格化的形式"></a>第二步：将二进制形式的浮点实数转化为规格化的形式</h2><p>小数点向左移动7个二进制位可以得到：<br>10110010.001=1.0110010001*2^7<br>因而产生了以下三项: </p><ul><li>符号位：该数为正数，故第31位为0，占一个二进制位。</li><li>阶码：指数为7，故其阶码为127+7=134=(10000110)(二进制)，占从第30到第23共8个二进制位。</li><li>尾数为小数点后的部分， 即0110010001。因为尾数共23个二进制位，在后面补13个0，即：01100100010000000000000</li></ul><p>所以，178.125在内存中的实际表示方式为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 10000110 01100100010000000000000</span><br></pre></td></tr></table></figure></p><hr><h1 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h1><p>再如，将-0.15625表示成机器内的32个字节的形式. </p><h2 id="第一步：将-0-15625表示成二进制形式"><a href="#第一步：将-0-15625表示成二进制形式" class="headerlink" title="第一步：将-0.15625表示成二进制形式"></a>第一步：将-0.15625表示成二进制形式</h2><p>(-0.15625)(十进制数)=(-0.00101)(二进制形式)</p><h2 id="第二步：将二进制形式的浮点数转化为规格化的形式"><a href="#第二步：将二进制形式的浮点数转化为规格化的形式" class="headerlink" title="第二步：将二进制形式的浮点数转化为规格化的形式"></a>第二步：将二进制形式的浮点数转化为规格化的形式</h2><p>小数点向右移动3个二进制位可以得到：<br>-0.00101=-1.01*2^(-3)<br>同样，产生了三项: </p><ul><li>符号位：该数为负数，故第31位为1，占一个二进制位。</li><li>阶码：指数为-3，故其阶码为127+(-3)=124=01111100，占从第30到第23共8个二进制位。</li><li>尾数为小数点后的01，当然后面要补21个0。<br>所以，-0.15625在内存中的实际表示形式为: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 01111100 01000000000000000000000</span><br></pre></td></tr></table></figure></li></ul><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>可以通过以下的C++程序验证之。记得添加编译选项<code>--std=c++11</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cast2bits</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bits</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b7 : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b6 : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b5 : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b4 : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b3 : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b2 : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b1 : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b0 : <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="built_in">ostringstream</span> oss;</span><br><span class="line">    <span class="built_in">ostringstream</span> data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">explicit</span> <span class="title">cast2bits</span>(<span class="title">const</span> <span class="title">T</span> &amp;<span class="title">input</span>) &#123;</span></span><br><span class="line">        data &lt;&lt; input &lt;&lt; <span class="string">" type: "</span> &lt;&lt; <span class="keyword">typeid</span>(input).name();</span><br><span class="line">        <span class="keyword">const</span> T *pTInput = &amp;input;</span><br><span class="line">        <span class="keyword">auto</span> *pBitsinput = (bits *) pTInput;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(T) / <span class="keyword">sizeof</span>(bits);</span><br><span class="line">        length = <span class="number">9</span> * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            oss &lt;&lt; (<span class="keyword">int</span>) ((pBitsinput + i)-&gt;b0)</span><br><span class="line">                &lt;&lt; (<span class="keyword">int</span>) ((pBitsinput + i)-&gt;b1)</span><br><span class="line">                &lt;&lt; (<span class="keyword">int</span>) ((pBitsinput + i)-&gt;b2)</span><br><span class="line">                &lt;&lt; (<span class="keyword">int</span>) ((pBitsinput + i)-&gt;b3)</span><br><span class="line">                &lt;&lt; (<span class="keyword">int</span>) ((pBitsinput + i)-&gt;b4)</span><br><span class="line">                &lt;&lt; (<span class="keyword">int</span>) ((pBitsinput + i)-&gt;b5)</span><br><span class="line">                &lt;&lt; (<span class="keyword">int</span>) ((pBitsinput + i)-&gt;b6)</span><br><span class="line">                &lt;&lt; (<span class="keyword">int</span>) ((pBitsinput + i)-&gt;b7)</span><br><span class="line">                &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> cast2bits &amp;c) &#123;</span><br><span class="line">        os &lt;&lt; c.data.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        os &lt;&lt; <span class="string">"M"</span> &lt;&lt; <span class="built_in">string</span>((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>) (c.length - <span class="number">2</span>), <span class="string">' '</span>) &lt;&lt; <span class="string">"L"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        os &lt;&lt; c.oss.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cast2bits(<span class="number">178.125f</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cast2bits(<span class="number">-0.15625f</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">178.125 type: f</span><br><span class="line">M L</span><br><span class="line">01000011 00110010 00100000 00000000 </span><br><span class="line"></span><br><span class="line">-0.15625 type: f</span><br><span class="line">M L</span><br><span class="line">10111110 00100000 00000000 00000000</span><br></pre></td></tr></table></figure></p><p>最后，这个程序其实不仅可以处理浮点数，也可以处理其他各种数据类型在内存中的表示形式。<br>比如，你可以试试以下代码的输出结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; cast2bits(<span class="number">178.125</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cast2bits(<span class="number">-0.15625</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cast2bits(<span class="number">123</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cast2bits(<span class="number">123l</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cast2bits(<span class="number">123l</span>l) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在服务器上部署jupyter供自己使用</title>
      <link href="/p/2019-03-19-reverse-proxy-jupyter.html"/>
      <url>/p/2019-03-19-reverse-proxy-jupyter.html</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>为了更方便地学习python，就寻思着在腾讯云服务器上部署一个jupyter服务。<br>但是，如果只是起一个<code>jupyter notebook</code>在后台运行，那我就必须访问<code>ladyrick.com:8888</code>来访问（假设端口为8888）。<br>这是非常丑陋的。<br>我希望可以通过访问<code>jupyter.ladyrick.com</code>来访问我的jupyter服务。</p><p>另外，为了防止别人访问，只为我一个人服务，需要给jupyter服务设置密码。</p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="1-为jupyter设置密码"><a href="#1-为jupyter设置密码" class="headerlink" title="1. 为jupyter设置密码"></a>1. 为jupyter设置密码</h2><p>这个非常简单了。直接运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook password</span><br></pre></td></tr></table></figure></p><p>然后根据提示，输入密码即可。</p><p>这会在<code>~/.jupyter/jupyter_notebook_config.json</code>文件中写入密码的哈希值，这样以后在新浏览器登陆时，就需要输入密码。</p><p><img src="./2019-03-19-reverse-proxy-jupyter/jupyter_passwork.png" alt></p><h2 id="2-设置apache反向代理"><a href="#2-设置apache反向代理" class="headerlink" title="2. 设置apache反向代理"></a>2. 设置apache反向代理</h2><p>首先我们先配置一下jupyter。</p><p>生成jupyter的配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure></p><p>这会将默认配置写入<code>~/.jupyter/jupyter_notebook_config.py</code>文件。</p><p>打开配置文件，修改配置项如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.port = <span class="number">8888</span> <span class="comment"># 自定义端口号。</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span> <span class="comment"># 不打开浏览器。因为这是在命令行服务器上，自然没有浏览器。</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">"localhost"</span> <span class="comment"># 配置IP地址。localhost表明jupyter服务只能在本机访问。</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">"/home/username/jupyter"</span> <span class="comment"># jupyter的起始文件夹。不配置的话就是home文件夹。最好用绝对路径。</span></span><br></pre></td></tr></table></figure></p><p>启用apache的一些mod。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod proxy proxy_http proxy_wstunnel</span><br></pre></td></tr></table></figure></p><p>配置apache。<br>在<code>/etc/apache2/sites-available</code>下新建配置文件<code>jupyter.conf</code>。<br>配置文件内容如下：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;VirtualHost *:80&gt;</span></span><br><span class="line"><span class="attribute"><span class="nomarkup">ServerName</span></span> jupyter.ladyrick.com</span><br><span class="line"><span class="attribute">ProxyRequests</span> <span class="literal">off</span></span><br><span class="line"></span><br><span class="line"><span class="section">&lt;Location /&gt;</span></span><br><span class="line"><span class="attribute">ProxyPass</span>        http://localhost:8888/</span><br><span class="line"><span class="attribute">ProxyPassReverse</span> http://localhost:8888/</span><br><span class="line"><span class="attribute">ProxyPassReverseCookieDomain</span> localhost jupyter.ladyrick.com</span><br><span class="line"><span class="attribute">RequestHeader</span> set Origin <span class="string">"http://localhost:8888"</span></span><br><span class="line"><span class="section">&lt;/Location&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">&lt;Location /api/kernels/&gt;</span></span><br><span class="line"><span class="attribute">ProxyPass</span>        ws://localhost:8888/api/kernels/</span><br><span class="line"><span class="attribute">ProxyPassReverse</span> ws://localhost:8888/api/kernels/</span><br><span class="line"><span class="section">&lt;/Location&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">&lt;Location /terminals/websocket/&gt;</span></span><br><span class="line"><span class="attribute">ProxyPass</span>        ws://localhost:8888/terminals/websocket/</span><br><span class="line"><span class="attribute">ProxyPassReverse</span> ws://localhost:8888/terminals/websocket/</span><br><span class="line"><span class="section">&lt;/Location&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">&lt;/VirtualHost&gt;</span></span><br></pre></td></tr></table></figure></p><p>保存关闭，并启用该配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo a2ensite jupyter.conf</span><br></pre></td></tr></table></figure></p><p>最后重启apache即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>密码配置简单，反向代理也很好配置，主要是一开始配置的反向代理，所有<code>ws://</code>协议的请求都失败了。<br>因此需要对websocket请求处理一下，不能直接使用顶层的配置，不然会转成http请求。<br>这个问题还困扰了挺久的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组前k小元素的各种方法对比</title>
      <link href="/p/2019-01-10-comparison-of-topk-algorithms.html"/>
      <url>/p/2019-01-10-comparison-of-topk-algorithms.html</url>
      
        <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p><strong>给定一个数组，寻找出数组中前k小的元素。</strong></p><p>对于这个经典问题，我之前一直只知道可以用<strong>堆</strong>来解决。</p><p>构造一个大根堆，然后遍历所有数据，如果数据小于堆顶元素，就替换堆顶元素，调整堆。</p><p>这样最后堆中的元素就是原数组中前k小的元素。</p><p>这个算法的时间复杂度为O(nlogk)。</p><a id="more"></a><p>但是，我发现，C++ stl 中关于堆的函数有，<code>make_heap</code>，<code>push_heap</code>，<code>pop_heap</code>，<code>sort_heap</code>，<code>is_heap</code>。</p><p>这其中，貌似并没有提供“替换堆顶元素，调整堆”的函数。要实现这个效果，可以通过先<code>pop_heap</code>，再<code>push_heap</code>来实现。</p><p>因此，我对这两种方式进行了一个对比：</p><ul><li>方法1：先<code>pop_heap</code>，再<code>push_heap</code>来替换堆顶元素。</li><li>方法2：自己实现调整堆顶元素的功能。</li></ul><h1 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h1><p>使用<code>pop_heap</code>和<code>push_heap</code>来两步调整堆顶。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">size_t</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::pop_heap and std::push_heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">    heap.reserve(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &lt; k) &#123;</span><br><span class="line">            heap.push_back(i);</span><br><span class="line">            push_heap(heap.begin(), heap.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; heap.front()) &#123;</span><br><span class="line">                pop_heap(heap.begin(), heap.end());</span><br><span class="line">                heap.back() = i;</span><br><span class="line">                push_heap(heap.begin(), heap.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><p>自己实现调整堆顶。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">size_t</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"replace heap top and adjust heap"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">    heap.reserve(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &lt; k) &#123;</span><br><span class="line">            heap.push_back(i);</span><br><span class="line">            push_heap(heap.begin(), heap.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; heap.front()) &#123;</span><br><span class="line">                heap.front() = i;</span><br><span class="line">                <span class="keyword">bool</span> adjust = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (adjust) &#123;</span><br><span class="line">                    <span class="keyword">int</span> largest = st;</span><br><span class="line">                    <span class="keyword">int</span> left = (st &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> right = (st &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> size = heap.size();</span><br><span class="line">                    <span class="keyword">if</span> (left &lt; size &amp;&amp; heap[left] &gt; heap[largest])</span><br><span class="line">                        largest = left;</span><br><span class="line">                    <span class="keyword">if</span> (right &lt; size &amp;&amp; heap[right] &gt; heap[largest])</span><br><span class="line">                        largest = right;</span><br><span class="line">                    <span class="keyword">if</span> (largest != st) &#123;</span><br><span class="line">                        <span class="built_in">std</span>::swap(heap[st], heap[largest]);</span><br><span class="line">                        st = largest;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        adjust = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法1 和方法2 的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::pop_heap and std::push_heap</span><br><span class="line">result = 31415926 CORRECT</span><br><span class="line">copy data time used = 15ms</span><br><span class="line">pure compute time used = 233ms</span><br><span class="line"></span><br><span class="line">replace heap top and adjust heap</span><br><span class="line">result = 31415926 CORRECT</span><br><span class="line">copy data time used = 15ms</span><br><span class="line">pure compute time used = 246ms</span><br></pre></td></tr></table></figure><p>果然，还是我写的调整堆顶太丑了，连stl的两步调整的效率都比不上。</p><p>理论上，一步调整堆顶的效率肯定会比两步调整要高吧。</p><p>所以结论是，下次遇到堆调整的问题，直接上<code>pop_heap</code>和<code>push_heap</code>。</p><hr><p>回到最初的问题。</p><p>对于寻找数组前k小元素的问题，在知乎上讨论之后，发现其实还有比建堆更高效的方法。</p><p>那就是不断使用partition算法。</p><p>partition算法是这样的，随机取出一个元素（比如就取最后的元素）作为枢轴（pivot），然后调整数组，把数组分为两部分，左边的都是不大于枢轴的，右边的都是不小于枢轴的。</p><p>通过使用一次partition算法，我们可以将数组分割。但是此时的分割不一定是符合要求的分割（枢轴不是第k个元素）。因此，我们需要不断分割，直到枢轴落到第k个元素。此时就找到了前k小的元素。</p><p>这个算法的时间复杂度为O(n)。</p><h1 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h1><p>使用stl的<code>std::nth_element</code>函数。</p><p>这个函数内部就是采用不断partition的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">size_t</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::nth_element"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    nth_element(data.begin(), data.begin() + k - <span class="number">1</span>, data.end());</span><br><span class="line">    display(data);</span><br><span class="line">    <span class="keyword">return</span> data[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::nth_element</span><br><span class="line">result = 31415926 CORRECT</span><br><span class="line">copy data time used = 14ms</span><br><span class="line">pure compute time used = 86ms</span><br></pre></td></tr></table></figure><p>可以看到运行速度一下快了一大截。</p><h1 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h1><p>自己手痒实现的类似<code>std::nth_element</code>的算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">size_t</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"my partition function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = data.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = left, r = right;</span><br><span class="line">        <span class="keyword">int</span> pivot = data[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; data[l] &lt;= pivot)</span><br><span class="line">                ++l;</span><br><span class="line">            data[r] = data[l];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; data[r] &gt;= pivot)</span><br><span class="line">                --r;</span><br><span class="line">            data[l] = data[r];</span><br><span class="line">        &#125;</span><br><span class="line">        data[l] = pivot;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            left = l + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            right = l - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my partition function</span><br><span class="line">result = 31415926 CORRECT</span><br><span class="line">copy data time used = 14ms</span><br><span class="line">pure compute time used = 84ms</span><br></pre></td></tr></table></figure><p>自己写的算法效率跟stl差不多。</p><h1 id="方法5"><a href="#方法5" class="headerlink" title="方法5"></a>方法5</h1><p>知乎上还有人说用<code>std::partial_sort</code>函数。</p><p>这个函数是部分排序函数，内部使用的是堆排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">size_t</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::partial_sort"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    partial_sort(data.begin(), data.begin() + k, data.end());</span><br><span class="line">    display(data);</span><br><span class="line">    <span class="keyword">return</span> data[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::partial_sort</span><br><span class="line">result = 31415926 CORRECT</span><br><span class="line">copy data time used = 13ms</span><br><span class="line">pure compute time used = 830ms</span><br></pre></td></tr></table></figure><p>太慢了吧。</p><h1 id="方法6"><a href="#方法6" class="headerlink" title="方法6"></a>方法6</h1><p>stl实现了一个优先队列，其实内部也是堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="keyword">size_t</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::priority_queue"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; prique;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prique.size() &lt; k) &#123;</span><br><span class="line">            prique.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prique.top() &gt; i) &#123;</span><br><span class="line">            prique.pop();</span><br><span class="line">            prique.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prique.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue</span><br><span class="line">result = 31415926 CORRECT</span><br><span class="line">copy data time used = 14ms</span><br><span class="line">pure compute time used = 268ms</span><br></pre></td></tr></table></figure><p>可以看到跟维护堆的方法效率差不多。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>对于“数组中前k小元素”的问题，有两种算法。</p><ol><li>维护堆数据结构。（O(nlogk)）</li><li>不断使用partition算法。（O(n)）</li></ol><p><strong>方法1</strong>的优点在于，可以不需要一次处理所有数据，也就是说可以处理流数据。</p><p>而且，其实不需要纠结<code>pop_heap</code>+<code>push_heap</code>，跟直接手动替换堆顶元素再调整堆，哪个更快。</p><p>除非stl官方实现了后者，我们还是用前者比较方便。或者用优先队列更省心。</p><p>如果用<strong>方法2</strong>，虽然时间复杂度比较低，但是其实波动很大。</p><p>在我的测试中，有时候可以比方法1高效10倍，有时候跟方法1差不多。</p><p>而且这种方法必须一次性处理所有数据，必须纵观全局。</p><p>至于<code>partial_sort</code>，拜拜了吧您。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ Puzzle</title>
      <link href="/p/2018-06-24-C++-puzzle.html"/>
      <url>/p/2018-06-24-C++-puzzle.html</url>
      
        <content type="html"><![CDATA[<p>本文搜集了一些有趣的C++的题目，有些题目令人大跌眼镜。来看看！</p><a id="more"></a><script>function toggle(that) {    var dom = that.parentElement.getElementsByClassName("cpuzzle-hint")[0];    var display = dom.style.display;    if (display == "none") {dom.style.display = "block"; that.textContent = "关闭提示";}    else {dom.style.display = "none"; that.textContent = "查看提示";}}</script><h2 id="请问输出结果是什么？如何解释？？"><a href="#请问输出结果是什么？如何解释？？" class="headerlink" title="请问输出结果是什么？如何解释？？"></a>请问输出结果是什么？如何解释？？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">23</span>, <span class="number">34</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">204</span>, <span class="number">99</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">-1</span>; d &lt;= (TOTAL_ELEMENTS - <span class="number">2</span>); d++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[d + <span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>测试发现实际输出结果为空。<br>sizeof运算符得到的是一个size_t类型，而size_t类型是无符号的。<br>当用有符号数跟无符号数比较时，会将有符号数转成无符号数，也就是将-1转成无符号数的最大值。<br><br>另外，size_t类型在不同位宽的机器上定义不同。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int64 <span class="keyword">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _WIN64 */</span></span></span><br></pre></td></tr></table></figure><br><br>PS: 更多关于32位机器和64位机器的区别，请看hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh<br></div></div><hr><h2 id="请问输出结果是什么？如何解释？？-1"><a href="#请问输出结果是什么？如何解释？？-1" class="headerlink" title="请问输出结果是什么？如何解释？？"></a>请问输出结果是什么？如何解释？？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(a,b) a##b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g(a) #a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> h(a) g(a)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; h(f(<span class="number">1</span>,<span class="number">2</span>)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g(f(<span class="number">1</span>,<span class="number">2</span>)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>测试发现输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">f(1,2)</span><br></pre></td></tr></table></figure><br><br>这里首先需要知道宏定义里面<code>#</code>的作用。<br>1. <code>#</code>： 其后必须跟一个宏参数，它的作用是将其后的参数内容转换为字符串。<br>2. <code>##</code>: 它的作用是拼接两个符号，如<code>a##1</code>，得到<code>a1</code>这两个符号不必是宏参数。<br><br>然后需要了解宏替换的规则。<br>1. 如果宏定义中没有<code>#</code>或者<code>##</code>，则先展开参数再进行替换(跟嵌套的函数调用一样)<br>2. 否则，参数不展开而是直接替换<br><br>在本题中，<code>h(a)</code>的定义中没有<code>#</code>或者<code>##</code>，所以宏定义展开流程是：<br>展开<code>f(1,2)</code> -&gt; 得到<code>12</code> -&gt; 展开<code>h(12)</code> -&gt; 得到<code>g(12)</code> -&gt; 展开<code>g(12)</code>发现定义中有<code>#</code> -&gt; 直接替换，得到<code>&quot;12&quot;</code><br><br>而<code>g(a)</code>的定义中有<code>#</code>或者<code>##</code>，因此会直接替换，在参数两边加上引号，不论参数是什么。于是直接得到字符串<code>&quot;f(1,2)&quot;</code><br></div></div><hr><h2 id="程序会输出None吗？"><a href="#程序会输出None吗？" class="headerlink" title="程序会输出None吗？"></a>程序会输出<code>None</code>吗？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ONE"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TWO"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        defalut:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"NONE"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>测试发现输出结果为空。<br>这个问题其实在于<code>default</code>拼写错误，写成了<code>defalut</code>。<br>但是真正可怕的是，不像是其它类型的拼写错误，本题的拼写错误，编译没有任何问题，没有人提示你<code>defalut</code>未定义。<br></div></div><hr><h2 id="它们相等吗？"><a href="#它们相等吗？" class="headerlink" title="它们相等吗？"></a>它们相等吗？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> f = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        f = f + <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="number">1.0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"f is 1.0\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"f is NOT 1.0\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>测试发现输出结果显示0.1累加10次并不等于1.0。<br>这是因为计算机中的浮点数，包括<code>float</code>和<code>double</code>类型，都是不精确的。因此累加的话会产生累积误差。<br>计算机中浮点数比较，不要直接用<code>==</code>比较，应该计算两者的差，当差小于某个阈值时认为相等。<br></div></div><hr><h2 id="逗号表达式可以正确赋值吗？"><a href="#逗号表达式可以正确赋值吗？" class="headerlink" title="逗号表达式可以正确赋值吗？"></a>逗号表达式可以正确赋值吗？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a : "</span> &lt;&lt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>编译错误。逗号表达式在C++中的运算优先级是最低的，因此，赋值运算会优先执行，导致编译器认为<code>2</code>是一个表达式，编译错误。<br>正确的写法是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><br><br></div></div><hr><h2 id="输出结果是什么？"><a href="#输出结果是什么？" class="headerlink" title="输出结果是什么？"></a>输出结果是什么？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> arr[SIZE])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of array is:"</span> &lt;&lt; <span class="keyword">sizeof</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[SIZE];</span><br><span class="line">    size(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>输出结果首先不是40。事实上，如果你自己编译了的话，就可以看到显示的警告。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: &apos;sizeof&apos; on array function parameter &apos;arr&apos; will return size of &apos;int*&apos; [-Wsizeof-array-argument]</span><br></pre></td></tr></table></figure><br><br>也就是说，虽然形参中定义的是数组，但是在函数中使用<code>sizeof</code>，还是会当作指针来计算。<br>在我的机器上，输出为8，因为我的是64位机器。<br></div></div><hr><h2 id="为什么会产生编译错误？"><a href="#为什么会产生编译错误？" class="headerlink" title="为什么会产生编译错误？"></a>为什么会产生编译错误？</h2><p>记住，将一个普通指针传递给const类型的指针是允许的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **p)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    foo(argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>因为这是二级指针，必须先强制类型转换才可以赋值。一级指针则不需要强制类型转换。<br><code>const char ** p</code>的意思是，类似这样的语句是无效的:<code>**p = &#39;a&#39;</code>。<br>我们看看假如允许<code>char**</code>到<code>const char**</code>的隐式类型转换的话，会发生什么。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 我们假设编译器存在漏洞X，允许char** 到 const char**的隐式类型转换。</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span> c = <span class="string">'a'</span>; <span class="comment">// c是一个常量。</span></span><br><span class="line">    <span class="keyword">char</span>* p_stupid = &amp;c; <span class="comment">// 愚蠢的指针，直接赋值是不行的，太过于耿直，编译错误。</span></span><br><span class="line">    <span class="keyword">char</span>* p_smart = <span class="literal">nullptr</span>; <span class="comment">// 这里有一个聪明的指针，学会了利用漏洞X来修改常量c。</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>** p_jump = &amp;p_smart; <span class="comment">// 利用漏洞X作为跳板。</span></span><br><span class="line"></span><br><span class="line">    *p_jump = &amp;c; <span class="comment">// 通过跳板，让p_smart强制指向c。</span></span><br><span class="line">    <span class="comment">// 注意这一步是最有意思的一步，因为这一步的两边都是const char*类型的，赋值完全没问题。</span></span><br><span class="line"></span><br><span class="line">    *p_smart = <span class="string">'b'</span>; <span class="comment">// 因为p_smart本身并不是const char*，所以现在p_smart就可以修改c了，把系统搞崩溃。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>注意看上述步骤，可以看到，除了<code>char const** p_jump = &amp;p_smart;</code>这一步，其他步骤没有任何漏洞。<br>因此我们可以看到，<strong>漏洞X</strong>是可以引发严重后果的。<br></div></div><hr><h2 id="输出是什么？"><a href="#输出是什么？" class="headerlink" title="输出是什么？"></a>输出是什么？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZEOF(arr) (sizeof(arr)/sizeof(arr[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PrintInt(expr) printf(<span class="meta-string">"%s:%d\n"</span>,#expr,(expr))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* The powers of 10 */</span></span><br><span class="line">    <span class="keyword">int</span> pot[] = &#123;</span><br><span class="line">            <span class="number">0001</span>,</span><br><span class="line">            <span class="number">0010</span>,</span><br><span class="line">            <span class="number">0100</span>,</span><br><span class="line">            <span class="number">1000</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZEOF(pot); i++)</span><br><span class="line">        PrintInt(pot[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>有了前面的关于宏定义的知识，你可能会得出，输出结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pot[i]:1</span><br><span class="line">pot[i]:10</span><br><span class="line">pot[i]:100</span><br><span class="line">pot[i]:1000</span><br></pre></td></tr></table></figure><br><br>但是，虽然躲过了宏定义的坑，其实还是错了，因为数组中的前三个数字带有前导0，这意味着是8进制。。。<br>所以正确的输出是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pot[i]:1</span><br><span class="line">pot[i]:8</span><br><span class="line">pot[i]:64</span><br><span class="line">pot[i]:1000</span><br></pre></td></tr></table></figure><br><br></div></div><hr><h2 id="输出是什么？肯定不是10"><a href="#输出是什么？肯定不是10" class="headerlink" title="输出是什么？肯定不是10"></a>输出是什么？肯定不是10</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PrintInt(expr) printf(<span class="meta-string">"%s : %d\n"</span>,#expr,(expr))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    y = y<span class="comment">/*p; /*dividing y by *p */</span>;</span><br><span class="line">    PrintInt(y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>这道题需要注意的是<code>y = y/*p;</code>。<br>如果是手写代码，或者没有代码高亮，可能确实会以为是<code>y</code>除以<code>*p</code>。<br>但是一旦有了代码高亮，瞬间就能看出，<code>/*p</code>其实是形成了块注释的开头。因此并不会执行除法。<br></div></div><hr><h2 id="如何实现乘5？"><a href="#如何实现乘5？" class="headerlink" title="如何实现乘5？"></a>如何实现乘5？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PrintInt(expr) printf(<span class="meta-string">"%s : %d\n"</span>,#expr,(expr))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FiveTimes</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = a &lt;&lt; <span class="number">2</span> + a;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">    PrintInt(FiveTimes(a));</span><br><span class="line">    PrintInt(FiveTimes(b));</span><br><span class="line">    PrintInt(FiveTimes(c));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>需要注意的是移位运算符的优先级低于加法，因此得到了错误的结果。<br></div></div><hr><h2 id="这个程序哪里有问题？"><a href="#这个程序哪里有问题？" class="headerlink" title="这个程序哪里有问题？"></a>这个程序哪里有问题？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ptr1, ptr2;</span><br><span class="line">    ptr1 = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ptr2 = ptr1;</span><br><span class="line">    *ptr2 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>定义指针类型，必须每个变量前面都加<code>*</code>。<br>修改：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr1, *ptr2;</span><br></pre></td></tr></table></figure><br><br></div></div><hr><h2 id="这个程序可以运行吗？"><a href="#这个程序可以运行吗？" class="headerlink" title="这个程序可以运行吗？"></a>这个程序可以运行吗？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(&amp;a[<span class="string">"Ya!Hello! how is this? %s\n"</span>], &amp;b[<span class="string">"junk/super"</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(&amp;a[<span class="string">"WHAT%c%c%c  %c%c  %c !\n"</span>], <span class="number">1</span>[<span class="string">"this"</span>],</span><br><span class="line">           <span class="number">2</span>[<span class="string">"beauty"</span>], <span class="number">0</span>[<span class="string">"tool"</span>], <span class="number">0</span>[<span class="string">"is"</span>], <span class="number">3</span>[<span class="string">"sensitive"</span>], <span class="number">4</span>[<span class="string">"CCCCCC"</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>是可以运行的。我们知道，数组下标引用<code>a[3]</code>，其实相当于是<code>*(a+3)</code>。因此，<code>a[3]</code>也可以写成<code>3[a]</code>。<br>因此，<code>a[&quot;Ya!Hello! how is this? %s\n&quot;]</code>相当于是<code>&quot;Ya!Hello! how is this? %s\n&quot;[3]</code>。<br></div></div><hr><h2 id="offsetof的原理是什么？"><a href="#offsetof的原理是什么？" class="headerlink" title="offsetof的原理是什么？"></a><code>offsetof</code>的原理是什么？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(a, b) ((size_t)(&amp;(((a*)(0))-&gt;b)))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, offsetof(test, a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, offsetof(test, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, offsetof(test, c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, offsetof(test, d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>工作原理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  (<span class="keyword">size_t</span>)(      <span class="comment">// 4.</span></span><br><span class="line">    &amp;( (         <span class="comment">// 3.</span></span><br><span class="line">      (a*)(<span class="number">0</span>)    <span class="comment">// 1.</span></span><br><span class="line">     )-&gt;b )      <span class="comment">// 2.</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><br>1. Casting the value zero to the struct pointer type <code>a*</code><br>2. Getting the struct field <code>b</code> of this (illegally placed) struct object<br>3. Getting the address of this <code>b</code> field<br>4. Casting the address to a <code>size_t</code><br><br>注意，现在已经不用这个了，用的是stddef.h自带的<code>offsetof</code>宏。它直接调用了编译器提供的函数<code>__builtin_offsetof</code>。<br>直接<code>include &lt;iostream&gt;</code>就可以使用了。<br></div></div><hr><h2 id="SWAP宏是如何工作的？"><a href="#SWAP宏是如何工作的？" class="headerlink" title="SWAP宏是如何工作的？"></a><code>SWAP</code>宏是如何工作的？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(a, b) ((a) ^= (b) ^= (a) ^= (b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    SWAP(a, b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div><strong onclick="toggle(this);" style="cursor:pointer;">查看提示</strong><div class="cpuzzle-hint" style="display:none;padding:10px;box-shadow:0 0 0 3px #f7f0f3 inset;"><br>可以把<code>(a) ^= (b) ^= (a) ^= (b)</code>展开来看。这个表达式，相当于以下三条语句依次执行的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><br><br>进行一些代换，得到：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _a = a;</span><br><span class="line"><span class="keyword">int</span> _b = b;</span><br><span class="line">a = _a ^ _b;</span><br><span class="line">b = _b ^ (_a ^ _b);</span><br><span class="line">a = (_a ^ _b) ^ (_b ^ (_a ^ _b));</span><br></pre></td></tr></table></figure><br><br>根据结合律，去掉所有括号。再根据交换律，以及<code>x^x</code>恒等于0，可以化简为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = _a;</span><br><span class="line">a = _b;</span><br></pre></td></tr></table></figure><br><br>因此该表达式可以实现交换两个变量的功能。<br></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用travis自动部署hexo博客到github pages</title>
      <link href="/p/2018-06-14-hexo-travis-deploy.html"/>
      <url>/p/2018-06-14-hexo-travis-deploy.html</url>
      
        <content type="html"><![CDATA[<p>之前的博客一直用的是wordpress，因为hexo的话，每次还得手动运行<code>hexo generate</code>，然后把public文件夹复制到腾讯云上。如果是使用github pages的话，也需要每次把public文件夹push上去。就感觉很繁琐，觉得还不如用wordpress，在线写文章。</p><p>后来，越来越觉得在线写文章是个很蛋疼的事情。而且，wordpress使用了数据库来存储文章，就感觉很不优雅。于是开始考虑换回hexo。</p><a id="more"></a><p>关于hexo部署繁琐的问题，最近接触了持续集成(CI, Continuous integration)，感觉可以用于自动部署，于是研究了一下，成功了。</p><p>目前使用的持续集成工具是<a href="https://travis-ci.org/" target="_blank" rel="noopener">travis</a>，使用github pages托管静态页面。现在的效果是，只要往github上一推送，就可以自动generate并将public文件夹push到gh-pages分支，实现github pages的自动更新。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>持续集成的原理是，每次检测到github上的提交，就运行一些预设的命令。<br>这些命令定义在仓库根目录下的<code>.travis.yml</code>文件中。<br>因此，只要合理配置这些命令，就可以让travis帮你完成generate和deploy的工作。</p><p>另一个需要解决的问题是，要让travis推送到你的github仓库，需要它有读写权限。<br>但是，我们总不能把github的密码写入配置文件中去吧？更不能把ssh密钥写入配置文件中。<br>好在，travis提供了加密功能，可以加密一个字符串，然后把加密的字符串写入配置文件中。这样就只有travis和你自己知道原始字符串的内容了。</p><p>另外，要让travis拥有读写仓库的权限，其实并不需要给它账号密码，或者ssh密钥。只需要给他一个personal access token即可。而且，这样还可以精确地控制travis的权限，而不是给它所有的用户权限。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="1-在github中添加personal-access-token"><a href="#1-在github中添加personal-access-token" class="headerlink" title="1. 在github中添加personal access token"></a>1. 在github中添加<code>personal access token</code></h2><p>打开<a href="https://github.com/settings/profile" target="_blank" rel="noopener">github的设置页面</a>，点击左侧的<code>Develpoer settings</code>进入开发者设置页面。<br>点击<code>Personal access tokens</code>，接着点击<code>Generate new token</code>。<br><code>Token description</code>一栏可以随便填，以供日后辨认即可。<br>在<code>Select scopes</code>中，勾选第一个选项，也就是<code>repo</code>选项。<br>最后点击<code>Generate token</code>，可以看到生成了一个很长的字符串，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">274e38cdf16e254da99a190ffbd0740b5ac3dcac</span><br></pre></td></tr></table></figure></p><p>记下它，以备后续使用。</p><h2 id="2-在仓库根目录创建travis配置文件"><a href="#2-在仓库根目录创建travis配置文件" class="headerlink" title="2. 在仓库根目录创建travis配置文件"></a>2. 在仓库根目录创建travis配置文件</h2><p>打开仓库文件夹，在根目录下新建<code>.travis.yml</code>文件，其内容如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span> <span class="comment"># 要安装的node版本为当前的稳定版。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span> <span class="comment"># 要缓存的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="comment"># install阶段执行的命令。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npx</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># script阶段执行的命令</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span> <span class="comment"># 最后执行的命令</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cd</span> <span class="string">public</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">echo</span> <span class="string">blog.ladyrick.com</span> <span class="string">&gt; CNAME # github pages服务，自定义域名</span></span><br><span class="line"><span class="string">- git init</span></span><br><span class="line"><span class="string">- git config user.name "ladyrick" # 配置git参数</span></span><br><span class="line"><span class="string">- git config user.email "ladyrick@qq.com" # 配置git参数</span></span><br><span class="line"><span class="string">- git add .</span></span><br><span class="line"><span class="string">- git commit -m "travis"</span></span><br><span class="line"><span class="string">- git push -f "https://$&#123;MY_TOKEN&#125;@github.com/ladyrick/hexo-blog.git" master:gh-pages</span></span><br><span class="line"><span class="string"># 强制push到gh-pages分支。注意这里使用了环境变量 $&#123;MY_TOKEN&#125;</span></span><br><span class="line"><span class="string"># 另外，注意修改仓库地址。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">master</span> <span class="comment"># 触发持续集成的分支</span></span><br></pre></td></tr></table></figure></p><p>这里需要注意我们使用了<code>${MY_TOKEN}</code>环境变量。这个环境变量定义了我们前面得到的<code>personal access token</code>。<br>但是，到目前为止，travis还无法识别这个环境变量。</p><h2 id="3-下载安装travis工具，定义环境变量。"><a href="#3-下载安装travis工具，定义环境变量。" class="headerlink" title="3. 下载安装travis工具，定义环境变量。"></a>3. 下载安装travis工具，定义环境变量。</h2><p>首先需要安装ruby环境。<a href="https://www.ruby-lang.org/" target="_blank" rel="noopener">Ruby官网</a><br>安装Ruby后，安装travis：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install travis</span><br></pre></td></tr></table></figure></p><p>接着，切换到仓库目录，执行以下命令(也可以不需要切换到仓库目录，但是需要添加参数<code>-r owner/project</code>)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis encrypt MY_TOKEN=<span class="string">"274e38cdf16e254da99a190ffbd0740b5ac3dcac"</span> --add</span><br></pre></td></tr></table></figure></p><p>这样即可将前面得到的<code>personal access token</code>赋给环境变量<code>MY_TOKEN</code>，生成加密字符串，并自动添加到<code>.travis.yml</code>文件中。<br>更多关于travis加密的内容请看<a href="https://docs.travis-ci.com/user/encryption-keys/" target="_blank" rel="noopener">travis文档</a>。</p><h2 id="4-在travis网站上启动持续集成"><a href="#4-在travis网站上启动持续集成" class="headerlink" title="4. 在travis网站上启动持续集成"></a>4. 在travis网站上启动持续集成</h2><p>最后一个步骤，很简单，打开<a href="https://travis-ci.org/profile" target="_blank" rel="noopener">https://travis-ci.org/profile</a>，用github账号登陆，找到你的仓库，点击按钮即可启动。</p><p>这样，以后每次push变更，都会触发travis的持续集成服务，自动完成构建，并推送到gh-pages分支。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/p/2018-06-05-hello-world.html"/>
      <url>/p/2018-06-05-hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>清华大学校内设置isatap隧道使用ipv6方法</title>
      <link href="/p/2018-05-16-tsinghua-isatap-ipv6.html"/>
      <url>/p/2018-05-16-tsinghua-isatap-ipv6.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍了在清华大学校内使用ipv6的方法，包括windows系统和ubuntu系统。</p><a id="more"></a><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>首先，在往下看以前，先试一下，你所在的宿舍楼，实验室，能不能使用原生的ipv6。<br>所谓原生的ipv6，指的是，插上网线就可以自动连接ipv6。<br>原生的ipv6是最好用的，不需要配置。但是清华校内只有部分地方支持，我不知道为什么。。。</p><p>好了，假如说你所在的网络不支持原生ipv6，那么你需要建立isatap隧道来连接ipv6。</p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>首先，需要禁用系统自带的6to4服务、teredo服务、以及原生ipv6环境。</p><ul><li><p>禁用6to4:</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface <span class="number">6</span>to4 <span class="built_in">set</span> state disable</span><br></pre></td></tr></table></figure></li><li><p>禁用teredo:</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface teredo <span class="built_in">set</span> state disable</span><br></pre></td></tr></table></figure></li><li><p>禁用原生ipv6环境:<br>打开控制面板-&gt;网络和Internet-&gt;网络连接，找到你正在使用的网络连接，右键-&gt;属性，在打开的对话框内，找到“Internet协议版本6(TCP/IPv6)”，取消勾选。</p></li></ul><p>接下来设置isatap。</p><p>输入下面的语句来配置：<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh interface isatap <span class="built_in">set</span> route isatap.tsinghua.edu.cn</span><br><span class="line">netsh interface isatap <span class="built_in">set</span> state enable</span><br></pre></td></tr></table></figure></p><p>注意事项：<br>学校的isatap服务器是<code>isatap.tsinghua.edu.cn</code>，ip地址是<code>166.111.21.1</code>。</p><h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sudo modprobe ipv6</span><br><span class="line">sudo ip tunnel del sit1</span><br><span class="line">MYIP=$(ifconfig enp2s0 | grep <span class="string">"inet "</span>|awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line"><span class="built_in">echo</span> My ip address: <span class="variable">$&#123;MYIP&#125;</span></span><br><span class="line">sudo ip tunnel add sit1 mode sit remote 166.111.21.1 <span class="built_in">local</span> <span class="variable">$&#123;MYIP&#125;</span></span><br><span class="line">sudo ifconfig sit1 up</span><br><span class="line">sudo ifconfig sit1 add 2402:f000:1:1501:200:5efe:<span class="variable">$&#123;MYIP&#125;</span>/64</span><br><span class="line">sudo ip route add ::/0 via 2402:f000:1:1501::1 metric 1</span><br></pre></td></tr></table></figure><p>注意事项：<br>第4行，是获取本机IP地址的命令。<code>enp2s0</code>是网卡名称。<br>第4行的命令目的是提取本机的IP地址。由于每个电脑的<code>ifconfig</code>命令运行结果不同，所以这个命令在其他电脑上很可能无法正确运行。到时候，可以直接手写IP地址，就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYIP=255.255.255.255</span><br></pre></td></tr></table></figure></p><p>第6行，学校的isatap服务器是<code>isatap.tsinghua.edu.cn</code>，ip地址是<code>166.111.21.1</code>。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>无论windows还是ubuntu，均可以使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping ipv6.google.com</span><br></pre></td></tr></table></figure></p><p>来测试是否成功连接ipv6。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++：explicit关键字</title>
      <link href="/p/2017-11-09-C++-explicit.html"/>
      <url>/p/2017-11-09-C++-explicit.html</url>
      
        <content type="html"><![CDATA[<p>explicit关键字作用于类的构造函数。一旦类的构造函数声明了explicit关键字，构造函数就必须使用显示的方式调用。这样做可以防止构造函数被不知不觉地，莫名其妙地调用。</p><a id="more"></a><p>下面举例子。</p><h1 id="在普通构造函数中的explicit："><a href="#在普通构造函数中的explicit：" class="headerlink" title="在普通构造函数中的explicit："></a>在普通构造函数中的explicit：</h1><p>类的定义如下（未声明explicit）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    num(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~num() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，由于未声明explicit，因此，可以使用这种方式来初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num a = <span class="number">1</span>;</span><br><span class="line">num b = <span class="number">2</span>;</span><br><span class="line"><span class="function">num <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>而且，如果你写了多个构造函数，有的有explicit，有的没有，代码就会自动去找没有声明explicit的构造函数去调用，就像是声明了explicit的构造函数不存在一样。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    num(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"int constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">num</span><span class="params">(<span class="keyword">float</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = <span class="keyword">int</span>(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"float constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num(<span class="keyword">double</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = <span class="keyword">int</span>(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"double constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~num() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num a = <span class="number">1</span>;</span><br><span class="line">num b = <span class="number">2.0f</span>;</span><br><span class="line">num c = <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure><p>此时，编译器会自动将<code>2.0f</code>转换成double，导致double constructor调用两次。但是，假如声明了explicit的不是float constructor，而是int或者double，就会直接导致编译不通过。因为，如果是int constructor声明了explicit，那么编译器无法决定int该转成float还是double。同理，如果是double constructor声明了explicit，那么编译器无法决定double该转成float还是int。这就很坑。凭什么float就可以义无反顾地转成了double，到了int和double就迷茫了？因此，我建议不要采用这种写法。</p><h1 id="在拷贝构造函数中的explicit："><a href="#在拷贝构造函数中的explicit：" class="headerlink" title="在拷贝构造函数中的explicit："></a>在拷贝构造函数中的explicit：</h1><p>类的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    num(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~num() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    num <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        n = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">num <span class="title">n</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">++n;</span><br><span class="line">++n;</span><br></pre></td></tr></table></figure><p>需要注意的是，在重载++运算符时，我返回了一个对象。在运行过程中，可以发现，我写的构造函数调用了一次，析构函数却调用了3次。这就是因为，返回的对象，其实是调用了拷贝构造函数，然后返回的一个匿名对象。因此，默认的拷贝构造函数被悄悄调用了两次。在实际中，可以通过返回引用的方法避免生成匿名对象。但是如何让编译器来帮我们检查，以避免这种事情发生呢？方法就是，将拷贝构造函数声明为explicit。如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    num(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">num</span><span class="params">(<span class="keyword">const</span> num&amp; nm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = nm.n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~num() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    num <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        n = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像这样写，就会导致编译错误。因为<code>++</code>运算符返回对象需要隐式调用拷贝构造函数，而explicit不让它被隐式调用。由于返回对象的时候，必然会隐式调用拷贝构造函数，所以这么做其实是根本性杜绝了返回对象这种操作（返回引用多好，返回对象吃力不讨好）。如果真的有需求，需要实现返回新的对象，可以在函数中构造一个local的对象，然后返回其引用。像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">    <span class="function">num <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这样会产生一个警告，告诉你返回了局部变量。注意，不要在函数中new一个对象，返回其引用。像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">    num* temp = <span class="keyword">new</span> num(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法会导致new的那个对象没法delete，对象没法析构，造成内存泄漏。如果运行的话，可以发现，析构函数调用次数会比构造函数少。</p><p><strong>题外话：关于直接赋值初始化</strong></p><p>前面说到，可以直接用赋值来进行初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num a = <span class="number">1</span>;</span><br><span class="line">num b = <span class="number">2.0f</span>;</span><br><span class="line">num c = <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure><p>在测试的时候，我发现，当普通构造函数和拷贝构造函数都自己写，并且拷贝构造函数的参数没有const关键字时，这种赋值的方式是会报错的，跟是否声明explicit无关。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    num(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num(num&amp; nm) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = nm.n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~num() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    num a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报的错是：<code>error: invalid initialization of non-const reference of type &#39;num&amp;&#39; from an rvalue of type &#39;num&#39;</code>。</p><p>OK，你说我不const，还说我是右值是吧？Fine。我改。修改方案1：参数改成const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num(<span class="keyword">const</span> num&amp; nm) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n = nm.n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"const copy constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改方案2：改成右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num(num&amp;&amp; nm) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n = nm.n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"right value copy constructor: "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试，这两种修改方案，都不会报错。更神奇的是，无论哪种修改方案，输出都显示只调用了普通的构造函数  (╯-_-)╯┴<strong>—</strong>┴ 拷贝构造函数内心：你根本不调用我，还管我管这么宽？经过轮子哥指点，终于明白了。<strong>GCC就是会帮你检查一下num(num(1))是否合法，然后当num(1)来生成代码的。</strong>真是无语呢……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows如何自定文件夹名称</title>
      <link href="/p/2017-09-17-windows-custom-folder-name.html"/>
      <url>/p/2017-09-17-windows-custom-folder-name.html</url>
      
        <content type="html"><![CDATA[<p>比如，桌面文件夹，其实真实的路径是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名\Desktop</span><br></pre></td></tr></table></figure></p><p>而不是桌面。</p><a id="more"></a><p>方法很简单。<br>假设要创建一个文件夹，名称叫做“代码”，路径是“code” 首先新建一个文件夹，名为code。<br>在文件夹下新建文件：desktop.ini 文件内容为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName=代码</span><br></pre></td></tr></table></figure><p>保存。 最后，在当前目录中打开cmd，执行命令</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">attrib</span> +s .</span><br></pre></td></tr></table></figure><p>为当前文件夹添加系统属性。<br><strong>注意：</strong>文件夹的真实路径必须是不带空格的英文。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>罗姆楼网络问题解决方案</title>
      <link href="/p/2016-12-12-rohm-network-problem.html"/>
      <url>/p/2016-12-12-rohm-network-problem.html</url>
      
        <content type="html"><![CDATA[<p>罗姆楼的网络问题真的是困扰了我很久。<br>从进入实验室开始，就不停断网……<br>一开始怀疑是网卡的问题，还自费买了个网卡，结果证明不是网卡的问题。<br>最神奇的是，使用win7好好的，一用win10，不到三分钟铁定断网。<br>这导致整个实验室都是用win7的……真心醉了。</p><a id="more"></a><p>后来找到了下面的方法，再加上自己的摸索，终于解决了这个问题。<br>不过，我猜，在我痛苦期间罗姆楼的网应该也整顿过……<br>再加上win10不断更新完善，<br>反正现在已经完全不会断网了。</p><h1 id="方法1：网关MAC静态绑定"><a href="#方法1：网关MAC静态绑定" class="headerlink" title="方法1：网关MAC静态绑定"></a>方法1：网关MAC静态绑定</h1><p>适用于windows7+<br>PS：请使用管理员身份打开命令提示符。</p><p>步骤(1): 用netsh i i show in命令查出你的网卡物理接口ID。</p><p>一个示例如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh i i show <span class="keyword">in</span></span><br></pre></td></tr></table></figure><p>该命令的输出可能是（每个计算机不一定一样）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Idx     Met         MTU          状态                名称</span><br><span class="line">---  ----------  ----------  ------------  ---------------------------</span><br><span class="line">  1          75  4294967295  connected     Loopback Pseudo-Interface 1</span><br><span class="line">  5           5        1500  disconnected  以太网</span><br><span class="line">  8          35        1500  connected     以太网 2</span><br></pre></td></tr></table></figure><p>从输出可以看出，示例中，正在使用的以太网的ID是 8<br>(博主有两个网口，ID为5的没有使用，显示状态为disconnected)</p><p>步骤(2): 通过netsh命令实现网关mac的静态绑定</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh -c "i i" add neighbors <span class="number">8</span> "<span class="number">166</span>.<span class="number">111</span>.<span class="number">64</span>.<span class="number">1</span>" "<span class="number">00</span>-<span class="number">22</span>-<span class="number">93</span>-<span class="number">59</span>-<span class="number">8</span>e-b1"</span><br></pre></td></tr></table></figure><p>其中8是上面查到的网卡ID，不同的电脑可能不一样。<br><code>00-22-93-59-8e-b1</code> 是网关的真实MAC地址，不要修改。</p><h1 id="方法2：重装驱动"><a href="#方法2：重装驱动" class="headerlink" title="方法2：重装驱动"></a>方法2：重装驱动</h1><p>如果以上方法还不行的话，建议去仔细地重装驱动，去笔记本电脑官网下载，去主板厂商官网下载。<br><strong>不要用各种自动装驱动的软件去装。</strong></p><p>博主使用上述的绑定+装驱动的方法解决了断网问题。</p><p><strong>相关：</strong><a href="/p/2018-05-16-tsinghua-isatap-ipv6.html" title="清华大学校内设置isatap隧道使用ipv6方法">清华大学校内设置isatap隧道使用ipv6方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 闲扯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
