{"meta":{"title":"Hello World","subtitle":null,"description":"Keep Coding","author":"ladyrick","url":"","root":"/"},"pages":[{"title":"关于我","date":"2019-03-20T16:52:07.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"。。。"},{"title":"我的朋友们","date":"2019-07-28T09:39:40.060Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"friends/index.html","permalink":"/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"C++ float数据在内存中的表示形式","slug":"c++-float-in-memory","date":"2019-07-28T09:21:41.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"p/2019-07-28-c++-float-in-memory.html","link":"","permalink":"/p/2019-07-28-c++-float-in-memory.html","excerpt":"介绍参考：https://blog.csdn.net/hemingliang1987/article/details/11630409简单地说，一个float型实数在内存中占4个字节，即32个二进制bit，从低位到高位依次叫第0位到第31位。这32位可以分为3个部分：符号位（第31位），阶码（第30位到第23位共8位），尾数（最低23位）。 符号位。最高位也就是第31位表示这个实数是正数还是负数，为0表示正数或0，为1表示负数。 阶码。第30位到第23位这8个二进制位表示该实数转化为规格化的二进制实数后的指数与127(127即所谓偏移量)之和即所谓阶码。规格化的二进制实数的指数只能在-127~+127之间，所以，一个float型数的最大值在+2^127即+3.4*10^38，最小值在-2^127即-3.4*10^38。 尾数。其他最低的23位即第22位到第0位表示该实数转化为规格化的二进制实数后小数点以后的其余各位即所谓尾数。","text":"介绍参考：https://blog.csdn.net/hemingliang1987/article/details/11630409简单地说，一个float型实数在内存中占4个字节，即32个二进制bit，从低位到高位依次叫第0位到第31位。这32位可以分为3个部分：符号位（第31位），阶码（第30位到第23位共8位），尾数（最低23位）。 符号位。最高位也就是第31位表示这个实数是正数还是负数，为0表示正数或0，为1表示负数。 阶码。第30位到第23位这8个二进制位表示该实数转化为规格化的二进制实数后的指数与127(127即所谓偏移量)之和即所谓阶码。规格化的二进制实数的指数只能在-127~+127之间，所以，一个float型数的最大值在+2^127即+3.4*10^38，最小值在-2^127即-3.4*10^38。 尾数。其他最低的23位即第22位到第0位表示该实数转化为规格化的二进制实数后小数点以后的其余各位即所谓尾数。 例一例如，将十进制178.125表示成机器内的32个字节的二进制形式。 第一步：将178.125表示成二进制数(178.125)(十进制数)=(10110010.001)(二进制形式) 第二步：将二进制形式的浮点实数转化为规格化的形式小数点向左移动7个二进制位可以得到：10110010.001=1.0110010001*2^7因而产生了以下三项: 符号位：该数为正数，故第31位为0，占一个二进制位。 阶码：指数为7，故其阶码为127+7=134=(10000110)(二进制)，占从第30到第23共8个二进制位。 尾数为小数点后的部分， 即0110010001。因为尾数共23个二进制位，在后面补13个0，即：01100100010000000000000 所以，178.125在内存中的实际表示方式为:10 10000110 01100100010000000000000 例二再如，将-0.15625表示成机器内的32个字节的形式. 第一步：将-0.15625表示成二进制形式(-0.15625)(十进制数)=(-0.00101)(二进制形式) 第二步：将二进制形式的浮点数转化为规格化的形式小数点向右移动3个二进制位可以得到：-0.00101=-1.01*2^(-3)同样，产生了三项: 符号位：该数为负数，故第31位为1，占一个二进制位。 阶码：指数为-3，故其阶码为127+(-3)=124=01111100，占从第30到第23共8个二进制位。 尾数为小数点后的01，当然后面要补21个0。所以，-0.15625在内存中的实际表示形式为: 11 01111100 01000000000000000000000 验证可以通过以下的C++程序验证之。记得添加编译选项--std=c++111234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;bitset&gt;#include &lt;typeinfo&gt;using namespace std;class cast2bits &#123;private: struct bits &#123; unsigned char b7 : 1; unsigned char b6 : 1; unsigned char b5 : 1; unsigned char b4 : 1; unsigned char b3 : 1; unsigned char b2 : 1; unsigned char b1 : 1; unsigned char b0 : 1; &#125;; int length; ostringstream oss; ostringstream data;public: template&lt;class T&gt; explicit cast2bits(const T &amp;input) &#123; data &lt;&lt; input &lt;&lt; \" type: \" &lt;&lt; typeid(input).name(); const T *pTInput = &amp;input; auto *pBitsinput = (bits *) pTInput; int n = sizeof(T) / sizeof(bits); length = 9 * n - 1; for (int i = n - 1; i &gt;= 0; --i) &#123; oss &lt;&lt; (int) ((pBitsinput + i)-&gt;b0) &lt;&lt; (int) ((pBitsinput + i)-&gt;b1) &lt;&lt; (int) ((pBitsinput + i)-&gt;b2) &lt;&lt; (int) ((pBitsinput + i)-&gt;b3) &lt;&lt; (int) ((pBitsinput + i)-&gt;b4) &lt;&lt; (int) ((pBitsinput + i)-&gt;b5) &lt;&lt; (int) ((pBitsinput + i)-&gt;b6) &lt;&lt; (int) ((pBitsinput + i)-&gt;b7) &lt;&lt; ' '; &#125; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const cast2bits &amp;c) &#123; os &lt;&lt; c.data.str() &lt;&lt; endl; os &lt;&lt; \"M\" &lt;&lt; string((unsigned long long int) (c.length - 2), ' ') &lt;&lt; \"L\" &lt;&lt; endl; os &lt;&lt; c.oss.str() &lt;&lt; endl; return os; &#125;&#125;;int main() &#123; cout &lt;&lt; cast2bits(178.125f) &lt;&lt; endl; cout &lt;&lt; cast2bits(-0.15625f) &lt;&lt; endl; return 0;&#125; 输出为：1234567178.125 type: fM L01000011 00110010 00100000 00000000 -0.15625 type: fM L10111110 00100000 00000000 00000000 最后，这个程序其实不仅可以处理浮点数，也可以处理其他各种数据类型在内存中的表示形式。比如，你可以试试以下代码的输出结果。12345cout &lt;&lt; cast2bits(178.125) &lt;&lt; endl;cout &lt;&lt; cast2bits(-0.15625) &lt;&lt; endl;cout &lt;&lt; cast2bits(123) &lt;&lt; endl;cout &lt;&lt; cast2bits(123l) &lt;&lt; endl;cout &lt;&lt; cast2bits(123ll) &lt;&lt; endl;","categories":[],"tags":[]},{"title":"在服务器上部署jupyter供自己使用","slug":"reverse-proxy-jupyter","date":"2019-03-19T09:16:29.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"p/2019-03-19-reverse-proxy-jupyter.html","link":"","permalink":"/p/2019-03-19-reverse-proxy-jupyter.html","excerpt":"需求为了更方便地学习python，就寻思着在腾讯云服务器上部署一个jupyter服务。但是，如果只是起一个jupyter notebook在后台运行，那我就必须访问ladyrick.com:8888来访问（假设端口为8888）。这是非常丑陋的。我希望可以通过访问jupyter.ladyrick.com来访问我的jupyter服务。 另外，为了防止别人访问，只为我一个人服务，需要给jupyter服务设置密码。","text":"需求为了更方便地学习python，就寻思着在腾讯云服务器上部署一个jupyter服务。但是，如果只是起一个jupyter notebook在后台运行，那我就必须访问ladyrick.com:8888来访问（假设端口为8888）。这是非常丑陋的。我希望可以通过访问jupyter.ladyrick.com来访问我的jupyter服务。 另外，为了防止别人访问，只为我一个人服务，需要给jupyter服务设置密码。 解决方案1. 为jupyter设置密码这个非常简单了。直接运行1jupyter notebook password 然后根据提示，输入密码即可。 这会在~/.jupyter/jupyter_notebook_config.json文件中写入密码的哈希值，这样以后在新浏览器登陆时，就需要输入密码。 2. 设置apache反向代理首先我们先配置一下jupyter。 生成jupyter的配置文件：1jupyter notebook --generate-config 这会将默认配置写入~/.jupyter/jupyter_notebook_config.py文件。 打开配置文件，修改配置项如下：1234c.NotebookApp.port = 8888 # 自定义端口号。c.NotebookApp.open_browser = False # 不打开浏览器。因为这是在命令行服务器上，自然没有浏览器。c.NotebookApp.ip = \"localhost\" # 配置IP地址。localhost表明jupyter服务只能在本机访问。c.NotebookApp.notebook_dir = \"/home/username/jupyter\" # jupyter的起始文件夹。不配置的话就是home文件夹。最好用绝对路径。 启用apache的一些mod。1sudo a2enmod proxy proxy_http proxy_wstunnel 配置apache。在/etc/apache2/sites-available下新建配置文件jupyter.conf。配置文件内容如下：12345678910111213141516171819202122&lt;VirtualHost *:80&gt;ServerName jupyter.ladyrick.comProxyRequests off&lt;Location /&gt;ProxyPass http://localhost:8888/ProxyPassReverse http://localhost:8888/ProxyPassReverseCookieDomain localhost jupyter.ladyrick.comRequestHeader set Origin \"http://localhost:8888\"&lt;/Location&gt;&lt;Location /api/kernels/&gt;ProxyPass ws://localhost:8888/api/kernels/ProxyPassReverse ws://localhost:8888/api/kernels/&lt;/Location&gt;&lt;Location /terminals/websocket/&gt;ProxyPass ws://localhost:8888/terminals/websocket/ProxyPassReverse ws://localhost:8888/terminals/websocket/&lt;/Location&gt;&lt;/VirtualHost&gt; 保存关闭，并启用该配置：1sudo a2ensite jupyter.conf 最后重启apache即可:1sudo service apache2 restart 总结密码配置简单，反向代理也很好配置，主要是一开始配置的反向代理，所有ws://协议的请求都失败了。因此需要对websocket请求处理一下，不能直接使用顶层的配置，不然会转成http请求。这个问题还困扰了挺久的。","categories":[],"tags":[]},{"title":"数组前k小元素的各种方法对比","slug":"comparison-of-topk-algorithms","date":"2019-01-10T06:46:25.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"p/2019-01-10-comparison-of-topk-algorithms.html","link":"","permalink":"/p/2019-01-10-comparison-of-topk-algorithms.html","excerpt":"引子给定一个数组，寻找出数组中前k小的元素。 对于这个经典问题，我之前一直只知道可以用堆来解决。 构造一个大根堆，然后遍历所有数据，如果数据小于堆顶元素，就替换堆顶元素，调整堆。 这样最后堆中的元素就是原数组中前k小的元素。 这个算法的时间复杂度为O(nlogk)。","text":"引子给定一个数组，寻找出数组中前k小的元素。 对于这个经典问题，我之前一直只知道可以用堆来解决。 构造一个大根堆，然后遍历所有数据，如果数据小于堆顶元素，就替换堆顶元素，调整堆。 这样最后堆中的元素就是原数组中前k小的元素。 这个算法的时间复杂度为O(nlogk)。 但是，我发现，C++ stl 中关于堆的函数有，make_heap，push_heap，pop_heap，sort_heap，is_heap。 这其中，貌似并没有提供“替换堆顶元素，调整堆”的函数。要实现这个效果，可以通过先pop_heap，再push_heap来实现。 因此，我对这两种方式进行了一个对比： 方法1：先pop_heap，再push_heap来替换堆顶元素。 方法2：自己实现调整堆顶元素的功能。 方法1使用pop_heap和push_heap来两步调整堆顶。 123456789101112131415161718int func(vector&lt;int&gt; &amp;data, size_t k) &#123; cout &lt;&lt; \"std::pop_heap and std::push_heap\" &lt;&lt; endl; vector&lt;int&gt; heap; heap.reserve(k); for (int i : data) &#123; if (heap.size() &lt; k) &#123; heap.push_back(i); push_heap(heap.begin(), heap.end()); &#125; else &#123; if (i &lt; heap.front()) &#123; pop_heap(heap.begin(), heap.end()); heap.back() = i; push_heap(heap.begin(), heap.end()); &#125; &#125; &#125; return heap.front();&#125; 方法2自己实现调整堆顶。 12345678910111213141516171819202122232425262728293031323334int func(vector&lt;int&gt; &amp;data, size_t k) &#123; cout &lt;&lt; \"replace heap top and adjust heap\" &lt;&lt; endl; vector&lt;int&gt; heap; heap.reserve(k); for (int i : data) &#123; if (heap.size() &lt; k) &#123; heap.push_back(i); push_heap(heap.begin(), heap.end()); &#125; else &#123; if (i &lt; heap.front()) &#123; heap.front() = i; bool adjust = true; int st = 0; while (adjust) &#123; int largest = st; int left = (st &lt;&lt; 1) + 1; int right = (st &lt;&lt; 1) + 2; int size = heap.size(); if (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) largest = left; if (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) largest = right; if (largest != st) &#123; std::swap(heap[st], heap[largest]); st = largest; &#125; else &#123; adjust = false; &#125; &#125; &#125; &#125; &#125; return heap.front();&#125; 方法1 和方法2 的运行结果如下： 123456789std::pop_heap and std::push_heapresult = 31415926 CORRECTcopy data time used = 15mspure compute time used = 233msreplace heap top and adjust heapresult = 31415926 CORRECTcopy data time used = 15mspure compute time used = 246ms 果然，还是我写的调整堆顶太丑了，连stl的两步调整的效率都比不上。 理论上，一步调整堆顶的效率肯定会比两步调整要高吧。 所以结论是，下次遇到堆调整的问题，直接上pop_heap和push_heap。 回到最初的问题。 对于寻找数组前k小元素的问题，在知乎上讨论之后，发现其实还有比建堆更高效的方法。 那就是不断使用partition算法。 partition算法是这样的，随机取出一个元素（比如就取最后的元素）作为枢轴（pivot），然后调整数组，把数组分为两部分，左边的都是不大于枢轴的，右边的都是不小于枢轴的。 通过使用一次partition算法，我们可以将数组分割。但是此时的分割不一定是符合要求的分割（枢轴不是第k个元素）。因此，我们需要不断分割，直到枢轴落到第k个元素。此时就找到了前k小的元素。 这个算法的时间复杂度为O(n)。 方法3使用stl的std::nth_element函数。 这个函数内部就是采用不断partition的方法。 123456int func(vector&lt;int&gt; &amp;data, size_t k) &#123; cout &lt;&lt; \"std::nth_element\" &lt;&lt; endl; nth_element(data.begin(), data.begin() + k - 1, data.end()); display(data); return data[k - 1];&#125; 运行结果如下： 1234std::nth_elementresult = 31415926 CORRECTcopy data time used = 14mspure compute time used = 86ms 可以看到运行速度一下快了一大截。 方法4自己手痒实现的类似std::nth_element的算法。 12345678910111213141516171819202122232425int func(vector&lt;int&gt; &amp;data, size_t k) &#123; cout &lt;&lt; \"my partition function\" &lt;&lt; endl; int left = 0, right = data.size() - 1; while (true) &#123; int l = left, r = right; int pivot = data[r]; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; data[l] &lt;= pivot) ++l; data[r] = data[l]; while (l &lt; r &amp;&amp; data[r] &gt;= pivot) --r; data[l] = data[r]; &#125; data[l] = pivot; if (l &lt; k - 1) &#123; left = l + 1; &#125; else if (l &gt; k - 1) &#123; right = l - 1; &#125; else &#123; return data[l]; &#125; &#125;&#125; 运行结果如下： 1234my partition functionresult = 31415926 CORRECTcopy data time used = 14mspure compute time used = 84ms 自己写的算法效率跟stl差不多。 方法5知乎上还有人说用std::partial_sort函数。 这个函数是部分排序函数，内部使用的是堆排序。 123456int func(vector&lt;int&gt; &amp;data, size_t k) &#123; cout &lt;&lt; \"std::partial_sort\" &lt;&lt; endl; partial_sort(data.begin(), data.begin() + k, data.end()); display(data); return data[k - 1];&#125; 运行结果如下： 1234std::partial_sortresult = 31415926 CORRECTcopy data time used = 13mspure compute time used = 830ms 太慢了吧。 方法6stl实现了一个优先队列，其实内部也是堆。 12345678910111213int func(vector&lt;int&gt; &amp;data, size_t k) &#123; cout &lt;&lt; \"std::priority_queue\" &lt;&lt; endl; priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; prique; for (int i : data) &#123; if (prique.size() &lt; k) &#123; prique.push(i); &#125; else if (prique.top() &gt; i) &#123; prique.pop(); prique.push(i); &#125; &#125; return prique.top();&#125; 运行结果如下： 1234std::priority_queueresult = 31415926 CORRECTcopy data time used = 14mspure compute time used = 268ms 可以看到跟维护堆的方法效率差不多。 结论对于“数组中前k小元素”的问题，有两种算法。 维护堆数据结构。（O(nlogk)） 不断使用partition算法。（O(n)） 方法1的优点在于，可以不需要一次处理所有数据，也就是说可以处理流数据。 而且，其实不需要纠结pop_heap+push_heap，跟直接手动替换堆顶元素再调整堆，哪个更快。 除非stl官方实现了后者，我们还是用前者比较方便。或者用优先队列更省心。 如果用方法2，虽然时间复杂度比较低，但是其实波动很大。 在我的测试中，有时候可以比方法1高效10倍，有时候跟方法1差不多。 而且这种方法必须一次性处理所有数据，必须纵观全局。 至于partial_sort，拜拜了吧您。","categories":[],"tags":[]},{"title":"C++ Puzzle","slug":"C++-puzzle","date":"2018-06-24T14:07:19.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"p/2018-06-24-C++-puzzle.html","link":"","permalink":"/p/2018-06-24-C++-puzzle.html","excerpt":"本文搜集了一些有趣的C++的题目，有些题目令人大跌眼镜。来看看！","text":"本文搜集了一些有趣的C++的题目，有些题目令人大跌眼镜。来看看！ function toggle(that) { var dom = that.parentElement.getElementsByClassName(\"cpuzzle-hint\")[0]; var display = dom.style.display; if (display == \"none\") {dom.style.display = \"block\"; that.textContent = \"关闭提示\";} else {dom.style.display = \"none\"; that.textContent = \"查看提示\";} } 请问输出结果是什么？如何解释？？12345678910#include &lt;iostream&gt;#define TOTAL_ELEMENTS (sizeof(array) / sizeof(array[0]))int array[] = &#123;23, 34, 12, 17, 204, 99, 16&#125;;int main() &#123; for (int d = -1; d &lt;= (TOTAL_ELEMENTS - 2); d++) std::cout &lt;&lt; array[d + 1] &lt;&lt; std::endl; return 0;&#125; 查看提示测试发现实际输出结果为空。sizeof运算符得到的是一个size_t类型，而size_t类型是无符号的。当用有符号数跟无符号数比较时，会将有符号数转成无符号数，也就是将-1转成无符号数的最大值。另外，size_t类型在不同位宽的机器上定义不同。如下：12345#ifdef _WIN64__MINGW_EXTENSION typedef unsigned __int64 size_t;#elsetypedef unsigned int size_t;#endif /* _WIN64 */PS: 更多关于32位机器和64位机器的区别，请看hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 请问输出结果是什么？如何解释？？1234567891011#include &lt;iostream&gt;#define f(a,b) a##b#define g(a) #a#define h(a) g(a)int main()&#123; std::cout &lt;&lt; h(f(1,2)) &lt;&lt; std::endl; std::cout &lt;&lt; g(f(1,2)) &lt;&lt; std::endl; return 0;&#125; 查看提示测试发现输出结果为1212f(1,2)这里首先需要知道宏定义里面#的作用。1. #： 其后必须跟一个宏参数，它的作用是将其后的参数内容转换为字符串。2. ##: 它的作用是拼接两个符号，如a##1，得到a1这两个符号不必是宏参数。然后需要了解宏替换的规则。1. 如果宏定义中没有#或者##，则先展开参数再进行替换(跟嵌套的函数调用一样)2. 否则，参数不展开而是直接替换在本题中，h(a)的定义中没有#或者##，所以宏定义展开流程是：展开f(1,2) -&gt; 得到12 -&gt; 展开h(12) -&gt; 得到g(12) -&gt; 展开g(12)发现定义中有# -&gt; 直接替换，得到&quot;12&quot;而g(a)的定义中有#或者##，因此会直接替换，在参数两边加上引号，不论参数是什么。于是直接得到字符串&quot;f(1,2)&quot; 程序会输出None吗？12345678910111213141516#include &lt;iostream&gt;int main() &#123; int a = 3; switch (a) &#123; case 1: std::cout &lt;&lt; \"ONE\"; break; case 2: std::cout &lt;&lt; \"TWO\"; break; defalut: std::cout &lt;&lt; \"NONE\"; &#125; return 0;&#125; 查看提示测试发现输出结果为空。这个问题其实在于default拼写错误，写成了defalut。但是真正可怕的是，不像是其它类型的拼写错误，本题的拼写错误，编译没有任何问题，没有人提示你defalut未定义。 它们相等吗？12345678910111213141516#include &lt;stdio.h&gt;int main() &#123; double f = 0.0; int i; for (i = 0; i &lt; 10; i++) f = f + 0.1; if (f == 1.0) printf(\"f is 1.0\\n\"); else printf(\"f is NOT 1.0\\n\"); return 0;&#125; 查看提示测试发现输出结果显示0.1累加10次并不等于1.0。这是因为计算机中的浮点数，包括float和double类型，都是不精确的。因此累加的话会产生累积误差。计算机中浮点数比较，不要直接用==比较，应该计算两者的差，当差小于某个阈值时认为相等。 逗号表达式可以正确赋值吗？1234567#include &lt;iostream&gt;int main() &#123; int a = 1, 2; std::cout &lt;&lt; \"a : \" &lt;&lt; a; return 0;&#125; 查看提示编译错误。逗号表达式在C++中的运算优先级是最低的，因此，赋值运算会优先执行，导致编译器认为2是一个表达式，编译错误。正确的写法是1int a = (1, 2); 输出结果是什么？12345678910111213#include &lt;iostream&gt;#define SIZE 10void size(int arr[SIZE]) &#123; std::cout &lt;&lt; \"size of array is:\" &lt;&lt; sizeof(arr);&#125;int main() &#123; int arr[SIZE]; size(arr); return 0;&#125; 查看提示输出结果首先不是40。事实上，如果你自己编译了的话，就可以看到显示的警告。1warning: &apos;sizeof&apos; on array function parameter &apos;arr&apos; will return size of &apos;int*&apos; [-Wsizeof-array-argument]也就是说，虽然形参中定义的是数组，但是在函数中使用sizeof，还是会当作指针来计算。在我的机器上，输出为8，因为我的是64位机器。 为什么会产生编译错误？记住，将一个普通指针传递给const类型的指针是允许的。123456void foo(const char **p) &#123;&#125;int main(int argc, char **argv) &#123; foo(argv); return 0;&#125; 查看提示因为这是二级指针，必须先强制类型转换才可以赋值。一级指针则不需要强制类型转换。const char ** p的意思是，类似这样的语句是无效的:**p = &#39;a&#39;。我们看看假如允许char**到const char**的隐式类型转换的话，会发生什么。12345678910111213int main()&#123; // 我们假设编译器存在漏洞X，允许char** 到 const char**的隐式类型转换。 char const c = 'a'; // c是一个常量。 char* p_stupid = &amp;c; // 愚蠢的指针，直接赋值是不行的，太过于耿直，编译错误。 char* p_smart = nullptr; // 这里有一个聪明的指针，学会了利用漏洞X来修改常量c。 char const** p_jump = &amp;p_smart; // 利用漏洞X作为跳板。 *p_jump = &amp;c; // 通过跳板，让p_smart强制指向c。 // 注意这一步是最有意思的一步，因为这一步的两边都是const char*类型的，赋值完全没问题。 *p_smart = 'b'; // 因为p_smart本身并不是const char*，所以现在p_smart就可以修改c了，把系统搞崩溃。&#125;注意看上述步骤，可以看到，除了char const** p_jump = &amp;p_smart;这一步，其他步骤没有任何漏洞。因此我们可以看到，漏洞X是可以引发严重后果的。 输出是什么？123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SIZEOF(arr) (sizeof(arr)/sizeof(arr[0]))#define PrintInt(expr) printf(\"%s:%d\\n\",#expr,(expr))int main() &#123; /* The powers of 10 */ int pot[] = &#123; 0001, 0010, 0100, 1000 &#125;; int i; for (i = 0; i &lt; SIZEOF(pot); i++) PrintInt(pot[i]); return 0;&#125; 查看提示有了前面的关于宏定义的知识，你可能会得出，输出结果是1234pot[i]:1pot[i]:10pot[i]:100pot[i]:1000但是，虽然躲过了宏定义的坑，其实还是错了，因为数组中的前三个数字带有前导0，这意味着是8进制。。。所以正确的输出是1234pot[i]:1pot[i]:8pot[i]:64pot[i]:1000 输出是什么？肯定不是101234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define PrintInt(expr) printf(\"%s : %d\\n\",#expr,(expr))int main() &#123; int y = 100; int *p; p = (int*)malloc(sizeof(int)); *p = 10; y = y/*p; /*dividing y by *p */; PrintInt(y); return 0;&#125; 查看提示这道题需要注意的是y = y/*p;。如果是手写代码，或者没有代码高亮，可能确实会以为是y除以*p。但是一旦有了代码高亮，瞬间就能看出，/*p其实是形成了块注释的开头。因此并不会执行除法。 如何实现乘5？1234567891011121314151617#include &lt;stdio.h&gt;#define PrintInt(expr) printf(\"%s : %d\\n\",#expr,(expr))int FiveTimes(int a) &#123; int t; t = a &lt;&lt; 2 + a; return t;&#125;int main() &#123; int a = 1, b = 2, c = 3; PrintInt(FiveTimes(a)); PrintInt(FiveTimes(b)); PrintInt(FiveTimes(c)); return 0;&#125; 查看提示需要注意的是移位运算符的优先级低于加法，因此得到了错误的结果。 这个程序哪里有问题？12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int *ptr1, ptr2; ptr1 = (int *) malloc(sizeof(int)); ptr2 = ptr1; *ptr2 = 10; return 0;&#125; 查看提示定义指针类型，必须每个变量前面都加*。修改：1int *ptr1, *ptr2; 这个程序可以运行吗？12345678910#include &lt;stdio.h&gt;int main() &#123; int a = 3, b = 5; printf(&amp;a[\"Ya!Hello! how is this? %s\\n\"], &amp;b[\"junk/super\"]); printf(&amp;a[\"WHAT%c%c%c %c%c %c !\\n\"], 1[\"this\"], 2[\"beauty\"], 0[\"tool\"], 0[\"is\"], 3[\"sensitive\"], 4[\"CCCCCC\"]); return 0;&#125; 查看提示是可以运行的。我们知道，数组下标引用a[3]，其实相当于是*(a+3)。因此，a[3]也可以写成3[a]。因此，a[&quot;Ya!Hello! how is this? %s\\n&quot;]相当于是&quot;Ya!Hello! how is this? %s\\n&quot;[3]。 offsetof的原理是什么？12345678910111213141516#include &lt;stdio.h&gt;#define offsetof(a, b) ((size_t)(&amp;(((a*)(0))-&gt;b)))struct test &#123; int a; double b; float c; int d[20];&#125;;int main() &#123; printf(\"%d\\n\", offsetof(test, a)); printf(\"%d\\n\", offsetof(test, b)); printf(\"%d\\n\", offsetof(test, c)); printf(\"%d\\n\", offsetof(test, d));&#125; 查看提示工作原理：1234567( (size_t)( // 4. &amp;( ( // 3. (a*)(0) // 1. )-&gt;b ) // 2. ))1. Casting the value zero to the struct pointer type a*2. Getting the struct field b of this (illegally placed) struct object3. Getting the address of this b field4. Casting the address to a size_t注意，现在已经不用这个了，用的是stddef.h自带的offsetof宏。它直接调用了编译器提供的函数__builtin_offsetof。直接include &lt;iostream&gt;就可以使用了。 SWAP宏是如何工作的？12345678910#include &lt;iostream&gt;#define SWAP(a, b) ((a) ^= (b) ^= (a) ^= (b))int main() &#123; int a = 1; int b = 2; SWAP(a, b); std::cout &lt;&lt; a &lt;&lt; b;&#125; 查看提示可以把(a) ^= (b) ^= (a) ^= (b)展开来看。这个表达式，相当于以下三条语句依次执行的结果。123a = a ^ b;b = b ^ a;a = a ^ b;进行一些代换，得到：12345int _a = a;int _b = b;a = _a ^ _b;b = _b ^ (_a ^ _b);a = (_a ^ _b) ^ (_b ^ (_a ^ _b));根据结合律，去掉所有括号。再根据交换律，以及x^x恒等于0，可以化简为：12b = _a;a = _b;因此该表达式可以实现交换两个变量的功能。","categories":[],"tags":[]},{"title":"使用travis自动部署hexo博客到github pages","slug":"hexo-travis-deploy","date":"2018-06-14T05:08:14.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"p/2018-06-14-hexo-travis-deploy.html","link":"","permalink":"/p/2018-06-14-hexo-travis-deploy.html","excerpt":"之前的博客一直用的是wordpress，因为hexo的话，每次还得手动运行hexo generate，然后把public文件夹复制到腾讯云上。如果是使用github pages的话，也需要每次把public文件夹push上去。就感觉很繁琐，觉得还不如用wordpress，在线写文章。 后来，越来越觉得在线写文章是个很蛋疼的事情。而且，wordpress使用了数据库来存储文章，就感觉很不优雅。于是开始考虑换回hexo。","text":"之前的博客一直用的是wordpress，因为hexo的话，每次还得手动运行hexo generate，然后把public文件夹复制到腾讯云上。如果是使用github pages的话，也需要每次把public文件夹push上去。就感觉很繁琐，觉得还不如用wordpress，在线写文章。 后来，越来越觉得在线写文章是个很蛋疼的事情。而且，wordpress使用了数据库来存储文章，就感觉很不优雅。于是开始考虑换回hexo。 关于hexo部署繁琐的问题，最近接触了持续集成(CI, Continuous integration)，感觉可以用于自动部署，于是研究了一下，成功了。 目前使用的持续集成工具是travis，使用github pages托管静态页面。现在的效果是，只要往github上一推送，就可以自动generate并将public文件夹push到gh-pages分支，实现github pages的自动更新。 原理持续集成的原理是，每次检测到github上的提交，就运行一些预设的命令。这些命令定义在仓库根目录下的.travis.yml文件中。因此，只要合理配置这些命令，就可以让travis帮你完成generate和deploy的工作。 另一个需要解决的问题是，要让travis推送到你的github仓库，需要它有读写权限。但是，我们总不能把github的密码写入配置文件中去吧？更不能把ssh密钥写入配置文件中。好在，travis提供了加密功能，可以加密一个字符串，然后把加密的字符串写入配置文件中。这样就只有travis和你自己知道原始字符串的内容了。 另外，要让travis拥有读写仓库的权限，其实并不需要给它账号密码，或者ssh密钥。只需要给他一个personal access token即可。而且，这样还可以精确地控制travis的权限，而不是给它所有的用户权限。 方法1. 在github中添加personal access token打开github的设置页面，点击左侧的Develpoer settings进入开发者设置页面。点击Personal access tokens，接着点击Generate new token。Token description一栏可以随便填，以供日后辨认即可。在Select scopes中，勾选第一个选项，也就是repo选项。最后点击Generate token，可以看到生成了一个很长的字符串，比如：1274e38cdf16e254da99a190ffbd0740b5ac3dcac 记下它，以备后续使用。 2. 在仓库根目录创建travis配置文件打开仓库文件夹，在根目录下新建.travis.yml文件，其内容如下：1234567891011121314151617181920212223242526272829language: node_jsnode_js: stable # 要安装的node版本为当前的稳定版。cache: directories: - node_modules # 要缓存的文件夹install:- npm install # install阶段执行的命令。script:- npx hexo generate # script阶段执行的命令after_script: # 最后执行的命令- cd public- echo blog.ladyrick.com &gt; CNAME # github pages服务，自定义域名- git init- git config user.name \"ladyrick\" # 配置git参数- git config user.email \"ladyrick@qq.com\" # 配置git参数- git add .- git commit -m \"travis\"- git push -f \"https://$&#123;MY_TOKEN&#125;@github.com/ladyrick/hexo-blog.git\" master:gh-pages# 强制push到gh-pages分支。注意这里使用了环境变量 $&#123;MY_TOKEN&#125;# 另外，注意修改仓库地址。branches: only: - master # 触发持续集成的分支 这里需要注意我们使用了${MY_TOKEN}环境变量。这个环境变量定义了我们前面得到的personal access token。但是，到目前为止，travis还无法识别这个环境变量。 3. 下载安装travis工具，定义环境变量。首先需要安装ruby环境。Ruby官网安装Ruby后，安装travis：1gem install travis 接着，切换到仓库目录，执行以下命令(也可以不需要切换到仓库目录，但是需要添加参数-r owner/project)：1travis encrypt MY_TOKEN=\"274e38cdf16e254da99a190ffbd0740b5ac3dcac\" --add 这样即可将前面得到的personal access token赋给环境变量MY_TOKEN，生成加密字符串，并自动添加到.travis.yml文件中。更多关于travis加密的内容请看travis文档。 4. 在travis网站上启动持续集成最后一个步骤，很简单，打开https://travis-ci.org/profile，用github账号登陆，找到你的仓库，点击按钮即可启动。 这样，以后每次push变更，都会触发travis的持续集成服务，自动完成构建，并推送到gh-pages分支。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-06-05T16:00:00.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"p/2018-06-05-hello-world.html","link":"","permalink":"/p/2018-06-05-hello-world.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"清华大学校内设置isatap隧道使用ipv6方法","slug":"tsinghua-isatap-ipv6","date":"2018-05-16T05:58:02.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"p/2018-05-16-tsinghua-isatap-ipv6.html","link":"","permalink":"/p/2018-05-16-tsinghua-isatap-ipv6.html","excerpt":"本文介绍了在清华大学校内使用ipv6的方法，包括windows系统和ubuntu系统。","text":"本文介绍了在清华大学校内使用ipv6的方法，包括windows系统和ubuntu系统。 准备首先，在往下看以前，先试一下，你所在的宿舍楼，实验室，能不能使用原生的ipv6。所谓原生的ipv6，指的是，插上网线就可以自动连接ipv6。原生的ipv6是最好用的，不需要配置。但是清华校内只有部分地方支持，我不知道为什么。。。 好了，假如说你所在的网络不支持原生ipv6，那么你需要建立isatap隧道来连接ipv6。 Windows首先，需要禁用系统自带的6to4服务、teredo服务、以及原生ipv6环境。 禁用6to4: 1netsh interface 6to4 set state disable 禁用teredo: 1netsh interface teredo set state disable 禁用原生ipv6环境:打开控制面板-&gt;网络和Internet-&gt;网络连接，找到你正在使用的网络连接，右键-&gt;属性，在打开的对话框内，找到“Internet协议版本6(TCP/IPv6)”，取消勾选。 接下来设置isatap。 输入下面的语句来配置：12netsh interface isatap set route isatap.tsinghua.edu.cnnetsh interface isatap set state enable 注意事项：学校的isatap服务器是isatap.tsinghua.edu.cn，ip地址是166.111.21.1。 Ubuntu123456789#!/bin/bashsudo modprobe ipv6sudo ip tunnel del sit1MYIP=$(ifconfig enp2s0 | grep \"inet \"|awk '&#123;print $2&#125;')echo My ip address: $&#123;MYIP&#125;sudo ip tunnel add sit1 mode sit remote 166.111.21.1 local $&#123;MYIP&#125;sudo ifconfig sit1 upsudo ifconfig sit1 add 2402:f000:1:1501:200:5efe:$&#123;MYIP&#125;/64sudo ip route add ::/0 via 2402:f000:1:1501::1 metric 1 注意事项：第4行，是获取本机IP地址的命令。enp2s0是网卡名称。第4行的命令目的是提取本机的IP地址。由于每个电脑的ifconfig命令运行结果不同，所以这个命令在其他电脑上很可能无法正确运行。到时候，可以直接手写IP地址，就像这样：1MYIP=255.255.255.255 第6行，学校的isatap服务器是isatap.tsinghua.edu.cn，ip地址是166.111.21.1。 测试无论windows还是ubuntu，均可以使用1ping ipv6.google.com 来测试是否成功连接ipv6。","categories":[],"tags":[]},{"title":"C++：explicit关键字","slug":"C++-explicit","date":"2017-11-09T08:14:33.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"p/2017-11-09-C++-explicit.html","link":"","permalink":"/p/2017-11-09-C++-explicit.html","excerpt":"explicit关键字作用于类的构造函数。一旦类的构造函数声明了explicit关键字，构造函数就必须使用显示的方式调用。这样做可以防止构造函数被不知不觉地，莫名其妙地调用。","text":"explicit关键字作用于类的构造函数。一旦类的构造函数声明了explicit关键字，构造函数就必须使用显示的方式调用。这样做可以防止构造函数被不知不觉地，莫名其妙地调用。 下面举例子。 在普通构造函数中的explicit：类的定义如下（未声明explicit）： 123456789101112class num &#123; int n;public: num(int n) &#123; this-&gt;n = n; cout &lt;&lt; \"constructor: \" &lt;&lt; n &lt;&lt; endl; &#125; ~num() &#123; cout &lt;&lt; \"destructor: \" &lt;&lt; n &lt;&lt; endl; &#125;&#125;; 此时，由于未声明explicit，因此，可以使用这种方式来初始化： 123num a = 1;num b = 2;num c(3); 而且，如果你写了多个构造函数，有的有explicit，有的没有，代码就会自动去找没有声明explicit的构造函数去调用，就像是声明了explicit的构造函数不存在一样。例如： 1234567891011121314151617181920212223class num &#123; int n;public: num(int n) &#123; this-&gt;n = n; cout &lt;&lt; \"int constructor: \" &lt;&lt; n &lt;&lt; endl; &#125; explicit num(float n) &#123; this-&gt;n = int(n); cout &lt;&lt; \"float constructor: \" &lt;&lt; n &lt;&lt; endl; &#125; num(double n) &#123; this-&gt;n = int(n); cout &lt;&lt; \"double constructor: \" &lt;&lt; n &lt;&lt; endl; &#125; ~num() &#123; cout &lt;&lt; \"destructor: \" &lt;&lt; n &lt;&lt; endl; &#125;&#125;; 调用： 123num a = 1;num b = 2.0f;num c = 3.0; 此时，编译器会自动将2.0f转换成double，导致double constructor调用两次。但是，假如声明了explicit的不是float constructor，而是int或者double，就会直接导致编译不通过。因为，如果是int constructor声明了explicit，那么编译器无法决定int该转成float还是double。同理，如果是double constructor声明了explicit，那么编译器无法决定double该转成float还是int。这就很坑。凭什么float就可以义无反顾地转成了double，到了int和double就迷茫了？因此，我建议不要采用这种写法。 在拷贝构造函数中的explicit：类的定义如下： 123456789101112131415161718class num &#123; int n;public: num(int n) &#123; this-&gt;n = n; cout &lt;&lt; \"constructor: \" &lt;&lt; n &lt;&lt; endl; &#125; ~num() &#123; cout &lt;&lt; \"destructor: \" &lt;&lt; n &lt;&lt; endl; &#125; num operator++() &#123; n = n + 1; return *this; &#125;&#125;; 调用： 123num n(3);++n;++n; 需要注意的是，在重载++运算符时，我返回了一个对象。在运行过程中，可以发现，我写的构造函数调用了一次，析构函数却调用了3次。这就是因为，返回的对象，其实是调用了拷贝构造函数，然后返回的一个匿名对象。因此，默认的拷贝构造函数被悄悄调用了两次。在实际中，可以通过返回引用的方法避免生成匿名对象。但是如何让编译器来帮我们检查，以避免这种事情发生呢？方法就是，将拷贝构造函数声明为explicit。如下。 1234567891011121314151617181920212223class num &#123; int n;public: num(int n) &#123; this-&gt;n = n; cout &lt;&lt; \"constructor: \" &lt;&lt; n &lt;&lt; endl; &#125; explicit num(const num&amp; nm) &#123; this-&gt;n = nm.n; cout &lt;&lt; \"copy constructor: \" &lt;&lt; n &lt;&lt; endl; &#125; ~num() &#123; cout &lt;&lt; \"destructor: \" &lt;&lt; n &lt;&lt; endl; &#125; num operator++() &#123; n = n + 1; return *this; &#125;&#125;; 像这样写，就会导致编译错误。因为++运算符返回对象需要隐式调用拷贝构造函数，而explicit不让它被隐式调用。由于返回对象的时候，必然会隐式调用拷贝构造函数，所以这么做其实是根本性杜绝了返回对象这种操作（返回引用多好，返回对象吃力不讨好）。如果真的有需求，需要实现返回新的对象，可以在函数中构造一个local的对象，然后返回其引用。像这样： 12345num&amp; operator++() &#123; n = n + 1; num temp(*this); return temp;&#125; 当然，这样会产生一个警告，告诉你返回了局部变量。注意，不要在函数中new一个对象，返回其引用。像这样： 12345num&amp; operator++() &#123; n = n + 1; num* temp = new num(*this); return *temp;&#125; 这种做法会导致new的那个对象没法delete，对象没法析构，造成内存泄漏。如果运行的话，可以发现，析构函数调用次数会比构造函数少。 题外话：关于直接赋值初始化 前面说到，可以直接用赋值来进行初始化。例如： 123num a = 1;num b = 2.0f;num c = 3.0; 在测试的时候，我发现，当普通构造函数和拷贝构造函数都自己写，并且拷贝构造函数的参数没有const关键字时，这种赋值的方式是会报错的，跟是否声明explicit无关。如下： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class num &#123; int n;public: num(int n) &#123; this-&gt;n = n; cout &lt;&lt; \"constructor: \" &lt;&lt; n &lt;&lt; endl; &#125; num(num&amp; nm) &#123; this-&gt;n = nm.n; cout &lt;&lt; \"copy constructor: \" &lt;&lt; n &lt;&lt; endl; &#125; ~num() &#123; cout &lt;&lt; \"destructor: \" &lt;&lt; n &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[]) &#123; num a = 1; return 0;&#125; 报的错是：error: invalid initialization of non-const reference of type &#39;num&amp;&#39; from an rvalue of type &#39;num&#39;。 OK，你说我不const，还说我是右值是吧？Fine。我改。修改方案1：参数改成const 1234num(const num&amp; nm) &#123; this-&gt;n = nm.n; cout &lt;&lt; \"const copy constructor: \" &lt;&lt; n &lt;&lt; endl;&#125; 修改方案2：改成右值引用 1234num(num&amp;&amp; nm) &#123; this-&gt;n = nm.n; cout &lt;&lt; \"right value copy constructor: \" &lt;&lt; n &lt;&lt; endl;&#125; 经过测试，这两种修改方案，都不会报错。更神奇的是，无论哪种修改方案，输出都显示只调用了普通的构造函数 (╯-_-)╯┴—┴ 拷贝构造函数内心：你根本不调用我，还管我管这么宽？经过轮子哥指点，终于明白了。GCC就是会帮你检查一下num(num(1))是否合法，然后当num(1)来生成代码的。真是无语呢……","categories":[],"tags":[]},{"title":"Windows如何自定文件夹名称","slug":"windows-custom-folder-name","date":"2017-09-17T05:30:47.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"p/2017-09-17-windows-custom-folder-name.html","link":"","permalink":"/p/2017-09-17-windows-custom-folder-name.html","excerpt":"比如，桌面文件夹，其实真实的路径是1C:\\Users\\用户名\\Desktop 而不是桌面。","text":"比如，桌面文件夹，其实真实的路径是1C:\\Users\\用户名\\Desktop 而不是桌面。 方法很简单。假设要创建一个文件夹，名称叫做“代码”，路径是“code” 首先新建一个文件夹，名为code。在文件夹下新建文件：desktop.ini 文件内容为： 12[.ShellClassInfo]LocalizedResourceName=代码 保存。 最后，在当前目录中打开cmd，执行命令 1attrib +s . 为当前文件夹添加系统属性。注意：文件夹的真实路径必须是不带空格的英文。","categories":[],"tags":[]},{"title":"罗姆楼网络问题解决方案","slug":"rohm-network-problem","date":"2016-12-12T03:06:34.000Z","updated":"2019-07-28T09:39:40.060Z","comments":true,"path":"p/2016-12-12-rohm-network-problem.html","link":"","permalink":"/p/2016-12-12-rohm-network-problem.html","excerpt":"罗姆楼的网络问题真的是困扰了我很久。从进入实验室开始，就不停断网……一开始怀疑是网卡的问题，还自费买了个网卡，结果证明不是网卡的问题。最神奇的是，使用win7好好的，一用win10，不到三分钟铁定断网。这导致整个实验室都是用win7的……真心醉了。","text":"罗姆楼的网络问题真的是困扰了我很久。从进入实验室开始，就不停断网……一开始怀疑是网卡的问题，还自费买了个网卡，结果证明不是网卡的问题。最神奇的是，使用win7好好的，一用win10，不到三分钟铁定断网。这导致整个实验室都是用win7的……真心醉了。 后来找到了下面的方法，再加上自己的摸索，终于解决了这个问题。不过，我猜，在我痛苦期间罗姆楼的网应该也整顿过……再加上win10不断更新完善，反正现在已经完全不会断网了。 方法1：网关MAC静态绑定适用于windows7+PS：请使用管理员身份打开命令提示符。 步骤(1): 用netsh i i show in命令查出你的网卡物理接口ID。 一个示例如下： 1netsh i i show in 该命令的输出可能是（每个计算机不一定一样）： 12345Idx Met MTU 状态 名称--- ---------- ---------- ------------ --------------------------- 1 75 4294967295 connected Loopback Pseudo-Interface 1 5 5 1500 disconnected 以太网 8 35 1500 connected 以太网 2 从输出可以看出，示例中，正在使用的以太网的ID是 8(博主有两个网口，ID为5的没有使用，显示状态为disconnected) 步骤(2): 通过netsh命令实现网关mac的静态绑定 1netsh -c \"i i\" add neighbors 8 \"166.111.64.1\" \"00-22-93-59-8e-b1\" 其中8是上面查到的网卡ID，不同的电脑可能不一样。00-22-93-59-8e-b1 是网关的真实MAC地址，不要修改。 方法2：重装驱动如果以上方法还不行的话，建议去仔细地重装驱动，去笔记本电脑官网下载，去主板厂商官网下载。不要用各种自动装驱动的软件去装。 博主使用上述的绑定+装驱动的方法解决了断网问题。 相关：清华大学校内设置isatap隧道使用ipv6方法","categories":[],"tags":[{"name":"闲扯","slug":"闲扯","permalink":"/tags/闲扯/"}]}]}